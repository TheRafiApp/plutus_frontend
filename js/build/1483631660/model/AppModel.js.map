{"version":3,"sources":["model/AppModel.js"],"names":["define","app","BaseModel","Backbone","Model","extend","idAttribute","name","dependents","search_filters","display_name","this","get","displayName","initialize","attributes","options","_","trim","_object","self","each","value","key","type","undefined","$","save","isNew","set","data","patch","method","changed_attrs","changedAttributes","Deferred","reject","changed","filters","omit","prototype","call"],"mappings":"AAIAA,QACE,MACA,gCAEF,SAASC,GAEP,GAAIC,GAAYC,SAASC,MAAMC,QAE7BC,YAAa,MACbC,KAAM,QAENC,cACAC,kBAGAC,aAAc,WACZ,MAAOC,MAAKC,IAAID,KAAKE,cAGvBC,WAAY,SAASC,EAAYC,GAC1BA,IAASA,MACTL,KAAKK,UAASL,KAAKK,YAExBL,KAAKK,QAAUC,EAAEZ,OAAOM,KAAKK,QAASA,IAIxCE,KAAM,SAASC,GACb,GAAIC,GAAOT,IACXM,GAAEI,KAAKF,EAAS,SAASG,EAAOC,GAE9B,GAAIC,SAAcF,EACN,WAARE,EACY,KAAVF,GAA0BG,SAAVH,QACXH,GAAQI,GAEfJ,EAAQI,GAAOG,EAAER,KAAKI,GAEP,UAARE,GACTJ,EAAKF,KAAKI,MAMhBK,KAAM,SAAUZ,EAAYC,GACrBA,IAASA,MAGVL,KAAKiB,SAASjB,KAAKO,KAAKH,GAG5BJ,KAAKkB,IAAId,EAGT,IAAIe,GAAOf,CAOX,IAJsBU,SAAlBT,EAAQe,QAAqBf,EAAQe,OAAQ,GACjDf,EAAQgB,OAAS,QAGZrB,KAAKiB,QAAS,CACjB,GAAIZ,EAAQe,SAAU,EAAM,CAC1B,GAAIE,GAAgBtB,KAAKuB,mBACzB,KAAKD,EAAe,MAAOP,GAAES,WAAWC,QAASC,SAAS,GAC1DP,GAAOG,EAETjB,EAAQgB,OAAS,MAInB,GAAIM,GAAU3B,KAAK2B,WAGnB,OAFAR,GAAOb,EAAEsB,KAAKT,EAAMQ,GAEbnC,SAASC,MAAMoC,UAAUb,KAAKc,KAAK9B,KAAMmB,EAAMd,KA8C1D,OAAOd","file":"AppModel.js","sourcesContent":["/**\n * BaseModel.js\n */\n\ndefine([\n  'app',\n  'vendor/backbone-computed.min',\n],\nfunction(app) {\n\n  var BaseModel = Backbone.Model.extend({\n\n    idAttribute: '_id',\n    name: 'model',\n\n    dependents: [],\n    search_filters: [],\n\n    // Return model's displayName\n    display_name: function() {\n      return this.get(this.displayName);\n    },\n\n    initialize: function(attributes, options) {\n      if (!options) options = {};\n      if (!this.options) this.options = {};\n\n      this.options = _.extend(this.options, options);\n    },\n\n    // Trim objects\n    trim: function(_object) {\n      var self = this;\n      _.each(_object, function(value, key) {\n\n        var type = typeof value;\n        if (type == 'string') {\n          if (value === '' || value === undefined) {\n            delete _object[key];\n          } else {\n            _object[key] = $.trim(value);\n          }\n        } else if (type == 'object') {\n          self.trim(value);\n        }\n      });\n    },\n\n    // Override default save to \n    save: function (attributes, options) {\n      if (!options) options = {};\n\n      // trim empty fields if new\n      if (this.isNew()) this.trim(attributes); \n\n      // set model with data\n      this.set(attributes);\n\n      // set attributes here to be possibly overwritten\n      var data = attributes;\n\n      // HACK: I modified backbone.js to allow patch for new models, line 645\n      if (options.patch === undefined) options.patch = true;\n      options.method = 'POST';\n\n      // if model is not new, check if anything changed\n      if (!this.isNew()) {\n        if (options.patch === true) {\n          var changed_attrs = this.changedAttributes();\n          if (!changed_attrs) return $.Deferred().reject({ changed: false });\n          data = changed_attrs;  \n        }\n        options.method = 'PUT';\n      }\n\n      // filter out undesired fields\n      var filters = this.filters || [];\n      data = _.omit(data, filters);\n\n      return Backbone.Model.prototype.save.call(this, data, options);\n    },\n    \n    /*\n    \n    // check if model has other models that depend on it\n    has_dependents: function() {\n      var self = this;\n\n      // clone dependents array, since we are about modify it\n      var args = this.dependents.slice(0);\n\n      // push callback function into arguments array\n      args.push(function() {\n        var dependent_models = {};\n\n        // loop through dependent fields to check if they exist\n        self.dependents.forEach(function(field) {\n          var attr = self.get(field);\n\n          // if models are in object array\n          if (attr.constructor === Array) {\n            if (attr.length) {\n              dependent_models[field] = attr.length;\n            }\n\n          // if model is just an attribute\n          } else {\n            if (attr.constructor === Object) {\n              if (!_.isEmpty(attr)) {\n                dependent_models[field] = 1;\n              }\n            }\n          }\n        });\n\n        return _.isEmpty(dependent_models) ? false : dependent_models;\n      });\n\n      // returning computed field should allow this to update dynamically\n      return Backbone.computed.apply(self, args);\n    }\n    */\n\n  });\n\n  return BaseModel; \n\n});"]}